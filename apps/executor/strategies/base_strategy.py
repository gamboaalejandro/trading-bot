"""
Base Strategy - Abstract base class for all trading strategies
"""
from abc import ABC, abstractmethod
from typing import Optional
from dataclasses import dataclass
from enum import Enum
import pandas as pd
import logging

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        signal_type: BUY, SELL, or HOLD
        confidence: Confidence level (0.0 to 1.0)
        entry_price: Suggested entry price
        stop_loss: Suggested stop loss price (optional)
        take_profit: Suggested take profit price (optional)
        metadata: Additional strategy-specific information
    """
    signal_type: SignalType
    confidence: float
    entry_price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: dict = None
    
    def __post_init__(self):
        """Validate signal after initialization."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0 and 1, got {self.confidence}")
        
        if self.metadata is None:
            self.metadata = {}
    
    def is_actionable(self, min_confidence: float = 0.6) -> bool:
        """Check if signal is strong enough to act on."""
        return (
            self.signal_type != SignalType.HOLD and
            self.confidence >= min_confidence
        )
    
    def to_dict(self) -> dict:
        """Convert signal to dictionary."""
        return {
            'signal_type': self.signal_type.value,
            'confidence': self.confidence,
            'entry_price': self.entry_price,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'metadata': self.metadata
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must implement:
    - generate_signal(): Analyze data and return a trading signal
    - get_required_candles(): Return minimum number of candles needed
    """
    
    def __init__(self, name: str):
        """
        Initialize strategy.
        
        Args:
            name: Strategy name
        """
        self.name = name
        self.signals_generated = 0
        self.logger = logging.getLogger(f"{__name__}.{name}")
    
    @abstractmethod
    async def generate_signal(self, df: pd.DataFrame) -> Optional[Signal]:
        """
        Analyze market data and generate trading signal.
        
        Args:
            df: DataFrame with OHLCV data (columns: open, high, low, close, volume)
            
        Returns:
            Signal object or None if not enough data
        """
        pass
    
    @abstractmethod
    def get_required_candles(self) -> int:
        """
        Get minimum number of candles required for this strategy.
        
        Returns:
            Minimum number of candles
        """
        pass
    
    def validate_dataframe(self, df: pd.DataFrame) -> bool:
        """
        Validate that DataFrame has required columns and enough data.
        
        Args:
            df: DataFrame to validate
            
        Returns:
            True if valid, False otherwise
        """
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        
        # Check columns
        if not all(col in df.columns for col in required_columns):
            self.logger.error(
                f"DataFrame missing required columns. "
                f"Expected: {required_columns}, Got: {list(df.columns)}"
            )
            return False
        
        # Check data length
        if len(df) < self.get_required_candles():
            self.logger.warning(
                f"Insufficient data: {len(df)} candles < "
                f"{self.get_required_candles()} required"
            )
            return False
        
        # Check for NaN values
        if df[required_columns].isnull().any().any():
            self.logger.warning("DataFrame contains NaN values")
            return False
        
        return True
    
    async def analyze(self, df: pd.DataFrame) -> Optional[Signal]:
        """
        Public method to analyze data and generate signal.
        Includes validation and logging.
        
        Args:
            df: DataFrame with OHLCV data
            
        Returns:
            Signal object or None
        """
        if not self.validate_dataframe(df):
            return None
        
        try:
            signal = await self.generate_signal(df)
            
            if signal:
                self.signals_generated += 1
                self.logger.info(
                    f"Signal generated: {signal.signal_type.value.upper()} "
                    f"(confidence: {signal.confidence:.2%})"
                )
            
            return signal
            
        except Exception as e:
            self.logger.error(f"Error generating signal: {e}", exc_info=True)
            return None
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}')"
